#!/usr/bin/env python3

import re
import webbrowser

import click
import git
import requests


_missing = object()
GH_PATTERN = re.compile(r'''
    ^(?:gh:|git@github\.com:|https://github.com/)  # protocol
    ([\w_-]+)/([\w_-]+)  # username/repo
    (?:\.git)?$
''', re.VERBOSE)


@click.command(context_settings={'help_option_names': ('-h', '--help')})
@click.option('--api-token', envvar='GITHUB_API_TOKEN')
@click.option('-b', '--branchname')
@click.option('--against', default='master')
@click.option('-u', '--upstream', default='origin')
@click.option('-w', '--open-page', is_flag=True)
@click.option('--create', type=click.Choice(('no', 'maybe', 'force')),
              default='no')
@click.option('-n', '--offline', is_flag=True)
def cli(create, **kwargs):
    check = CheckPR(**kwargs)
    links = check.available_links()
    has_open_pr = links and check.print_available_links(links)
    if create != 'no' or not has_open_pr:
        if create == 'no':
            check.prompt_new()
        elif not (create == 'maybe' and has_open_pr):
            if has_open_pr:
                click.echo('Force create. This may not be a great idea')
            check.create()


class CheckPR:
    def __init__(self, *, api_token, branchname, against, upstream, open_page,
                 offline):
        self.api_token = api_token
        self.branchname = branchname
        self.against = against
        self.upstream = upstream
        self.should_open_page = open_page
        self.offline = offline
        self._read_git_props()

    def available_links(self):
        results = () if self.offline else self._request_prs()
        def augment(pr):
            link = pr.get('_links', {}).get('html', {}).get('href')
            if link:
                pr['_jp_link'] = link
                return pr
            return None
        return [*filter(None, map(augment, results))]

    def print_available_links(self, links=None):
        if links is None:
            links = self.available_links()
        match = False
        for pr in links:
            link = pr.get('_jp_link')
            baseref = pr.get('base', {}).get('ref')
            state = pr.get('state')
            click.echo(
                f'Pull request against {baseref} ({state}) at {link}')
            if baseref == self.against and state == 'open':
                match = True
                self._maybe_open(link)
        return match

    def prompt_new(self):
        link = (f'https://github.com/{self._slug}/pull/new'
                       f'/{self.against}...{self.remote_name}')
        click.echo(f'Open a new pull request against {self.against}:'
                   f' {link}')
        self._maybe_open(link)

    def create(self):
        click.echo('Creating new pull request not supported yet.')
        self.prompt_new()

    def _request_prs(self):
        api = f'https://api.github.com/repos/{self._slug}/pulls'
        params = {'head': f'{self.owner}:{self.remote_name}', 'state': 'all'}
        headers = {'Authorization': f'token {self.api_token}'}
        resp = requests.get(api, params=params, headers=headers)
        resp.raise_for_status()
        return resp.json()

    def _maybe_open(self, link):
        if self.should_open_page:
            self.should_open_page = False
            webbrowser.open(link)

    def _read_git_props(self):
        self.repo = git.Repo()
        self._parse_gh_url()

        if self.branchname is None:
            branch = self.repo.active_branch
        else:
            for branch in self.repo.branches:
                if branch.name == self.branchname:
                    break
            else:
                abort(f'No branch {self.branchname} found.')

        tracking = branch.tracking_branch()
        if tracking is None:
            abort('This branch is not tracked. Please push first.')
        if tracking.commit != branch.commit:
            click.echo('Mismatch between tracking and local, you may want to push',
                       err=True)
        self.remote_name = tracking.remote_head

    def _parse_gh_url(self):
        gh_base = self.repo.remote(self.upstream).url
        gh_match = GH_PATTERN.match(gh_base)
        if gh_match is None:
            abort(f'Remote url {gh_base} suggests this is not a github repo.')
        self.owner, self.repo_name = gh_match.groups()

    @property
    def _slug(self):
        return f'{self.owner}/{self.repo_name}'


def _is_github(remote_url):
    return remote_url == 'gh' or 'github.com' in remote_url


def abort(message, **kwargs):
    click.echo(message, err=True, **kwargs)
    click.get_current_context().abort()


if __name__ == '__main__':
    cli()
