#!/bin/bash
# shellcheck disable=SC1090

function addhost(){
    for x in "$@" ; do
      echo adding "$x"
      sed "s/%HOST%/$x/" ~/.ssh/config_template >>~/.ssh/config
    done
}

function c(){
  local DIR="$1"
  shift
  if [[ ! -d "$DIR" ]] ; then
    mkdir -pv "$DIR" >&2
    local RESULT=$?
    [[ $RESULT == 0 ]] || return $RESULT
  fi
  echo "$DIR" >&2
  if [[ -z "$*" ]] ; then
    cd "$DIR" || return 1  # make shellcheck happy; this should never happen
  else
    ( cd "$DIR" && "$@" )
  fi
}

# not supported on mac
# TODO create conditional on mac
function ppid() {
  local PID=$$ ; ps --pid "$(cat /proc/$PID/ppid)"
}

function create_alias() {
  for x ; do
    echo alias "'$x'" >>~/bashrc.d/alias
    source ~/bashrc.d/alias
  done
}

function code() {
  local suff="$1"
  if [[ -z "$suff" ]] ; then
    if [[ -d ~/code/"${PASSARO_CODE_LOC}" ]] ; then
      c ~/code/"${PASSARO_CODE_LOC}"
      return 0
    else
      local suff="-wc"
    fi
  fi
  local folders=(~/code/*"$suff")
  local numf="${#folders[@]}"
  case "$numf" in
    1) ;;
    *)
        echo >&2 "$numf" folders found for "*$suff", please be more specific:
	for folder in "${folders[@]}" ; do
           printf >&2 "\\t%s\\n" "$folder"
        done
	return 2 ;;
  esac
  for folder in "${folders[@]}" ; do
    if [[ -d "$folder" ]] ; then
      c "$folder"
    else
      echo >&2 "No folder found for *$suff"
      return 1
    fi
    [[ ! -d .git ]] || git status
  done
}

function space() {
  local lines=${LINES}
  local arg="${1:-0}"
  local neg=""
  local div=""
  [[ -n "$1" && "$arg" != -* ]] || { neg=x ; arg=${arg##-} ; }
  [[ "${arg}" != /* ]] || { div=x ; arg="${arg##/}" ; }
  [[ "${arg}" != *[^0-9]* ]] || return 1 ;
  [[ -z "$div" ]] || arg="$((LINES / arg))"
  [[ -z "$neg" ]] && lines="$arg" || lines="$((lines - arg))"
  seq "$lines" | tr -dC \\n
}

# quickly access vimrc.
# If you source another vimrc from this one, do "vimrc 1" to go straight to it.
# "vimrc 2", "vimrc 3", etc to go to the second or third sourced file
function vimrc() {
  local OPTS=()
  if [[ "$#" != 0 ]] ; then
    local n
    case "$1" in
      0|*[^0-9]*) n=1 ;;
      *)  n="$1" ;;
    esac
    while [[ "$((n--))" -gt 0 ]] ; do
      OPTS=("${OPTS[@]}" '+/^source')
    done
    # shellcheck disable=SC2016
    OPTS=("${OPTS[@]}" '+normal $gf')
  fi
  vim ~/.vimrc "${OPTS[@]}"
}

# quickly access vim help
function :help() {
  vim "+help $1" "+silent only"
}

function _condition_venv() {
  for venv in venv .venv ; do
    local prg="${venv}/bin/${1}"
    if [[ -e "$prg" ]] ; then
      echo "$prg"
      return 0
    fi
  done
  echo >&2 venv "$1" not found
  return 1
}

function _exec_venv() {
  local prg result
  prg="$(_condition_venv "$1")"
  result="$?"
  if [[ "$result" == 0 ]] ; then
    shift
    "$prg" "$@"
  fi
  return "$result"
}

function py() {
  _exec_venv python "$@"
}

function pi() {
  _exec_venv pip "$@"
}

function loggit() {
  if set +o | grep -Fq 'set +o pipefail' ; then
    function loggit__exit() {
      trap - RETURN
      unset -f loggit__exit
      set +o pipefail
    }
    trap loggit__exit RETURN
    set -o pipefail
  fi
  name="$1"
  shift
  "$@" 2>&1 | tee /tmp/log-"${name}-$(gdate --iso=seconds | sed 's/-[^-]*$//;y/T:/_-/').log"
}

function logname() {
  local prefix=
  local num=
  while [[ -n "$1" ]] ; do
    local arg="$1"
    if [[ "$arg" =~ ^[1-9][0-9]*$ ]] ; then
      if [[ -z "$num" ]] ; then
        num="$arg"
      else
        echo "two numbers provided" >&2
        return 1
      fi
    elif [[ -z "$prefix" ]] ; then
      prefix="$arg"
    else
      echo "bad input" >&2
      return 1
    fi
    shift
  done
  if [[ -z "$num" ]] ; then
    num=1
  fi
  local pattern=/tmp/log
  if [[ -n "$prefix" ]] ; then
    pattern="${pattern}-${prefix}"
  fi
  local x
  for x in "${pattern}"-* ; do
    if [[ "$((--n))" -le 0 ]] ; then
      echo "$x"
      return
    fi
  done
}

function lesslog() {
  local lname rv
  lname="$(logname "$@")"
  rv="$?"
  if [[ "$rv" != 0 ]] ; then
    return "$rv"
  fi
  less "$lname"
}

function activate() {
  local prg
  prg="$(_condition_venv activate)" && source "$prg"
}

function bring() {
  mv -v "$@" .
}

# likely mac-only and very possibly iterm2-only. TODO verify that, check for
# it before defining the function
function remind() {
  sleeptime="${1:?usage: remind SLEEPTIME message text}"
  (
    sleep "$sleeptime"
    shift
    echo -ne '\e]9;'"$*"'\007'
  ) &
}

# list functions
function functions() {
  declare -f | sed '/^{ *$/,/^} *$/ d'
}

# look for vim swap files in current file tree
function hasvim() {
  find . -maxdepth "${1:-5}" -name '[._]*.sw*' -o -name '.sw*'
}

function _backup_progress_log() {
  local target="${1-.progress/log.txt}"
  local match
  match="$(ggrep -Pom1 '^Date: \d{4}-\d{2}-\d{2}' "$target")"
  if [[ "$?" != 0 ]] ; then
    echo >&2 'no date found in progress log, could not back up'
    return 1
  fi
  cp -vf "$target" "${target}.${match#Date: }"
}

function progress() {
  if [[ ! -f .progress/log.txt ]] ; then
    echo >&2 no progress log found, create one by calling progress-init
    return 1
  fi
  if ! git config jp.progress.promptnext >/dev/null ; then
    echo >&2 "Please set git config jp.progress.promptnext to use this"
    return 1
  fi
  local -a sw
  sw=(.progress/.log.txt.sw*)
  if [[ "${#sw[@]}" != 0 && -f "${sw[0]}" ]] ; then
    echo >&2 you have progress log open already: "${sw[@]}"
    return 1
  fi
  _backup_progress_log
  vi .progress/log.txt || return "$?"
  space
  _backup_progress_log
  echo 'Good work today!'
  echo
  sed -n '/{START LOG}/,/{END LOG}/ p' .progress/log.txt
  echo
  echo
  git config jp.progress.promptnext
}

function progress-init() {
  if [[ -f .progress/log.txt ]] ; then
    echo >&2 .progress/log.txt already exists. Skipping.
    return 1
  fi
  mkdir -p .progress || return "$?"
  echo creating .progress/log.txt
  cat <<-EOF >.progress/log.txt
	# This is your Progress Log.
	# Place whatever frontmatter you like here.
	# Use :ProgressNext to start a new session.

	{START LOG}
	Date: $(date +%F)

	What was my goal for today? @goalsfortoday


	What did I achieve? @actualaccomplishment


	What am I tackling next? @nextdaygoals


	{END LOG}
	Floating notes:

	EOF
  echo Finished. Remember to add .progress/log.txt to .git/info/exclude
}

# create pgrep-like function
if ! check-for-package --optional pgrep ; then
  function pgrep() {
    if [[ "$#" != 1 || -z "$1" ]] ; then
      echo >&2 usage: pgrep process-pattern
      echo >&2 'for more, you should install real pgrep'
      return 1
    elif [[ "$1" == -* ]] ; then
      echo >&2 Options not supported, you should install real pgrep
      return 1
    fi
    # shellcheck disable=SC2009
    ps -ef | grep -q "$1"
  }
  echo >&2 'Consider installing pgrep; we create a shabby ps+grep replacement instead'
fi
